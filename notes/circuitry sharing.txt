msa extension and hashing circuitry use the most compute resources
what if worker cores could share these?

msa extension process:
    retrieve 4 entries from RAM (8-12 instructions)
    manipulate 2 of them and keep 2 as-is (combinatorial so fast)
    pull result into RAM (3 instructions, but only 1 depends on msa extender)
    update registers and loop (3 instructions)

    so overall, circuitry only being "used" for 1 instruction out of 15

hashing process:
    pull 2 values from RAM (4 instructions)
    pass everything into hash unit and extract new values (mostly combinatorial, 1 instruction)
    update registers and loop (4 instructions)

    this circuit is only used for 1 instruction out of 9

lets see what msa and hashing process could look like from core perspective
    msa extension
        buffer i16, i15, i7, i2 and present to outputs
        select msa output buffer
            OUTPUTK buf_msa, op_bufsel_parity

        notify msa extension unit that it is ready (somehow)
        trap self in loop
            .trap:
            JUMP    .trap

        eventually core is recognized with interrupt
        when interrupt_ack goes high, write read_buf with the msa out value!!

    hashing
        really similar
        buffer msa and rc values and present all to outputs

        notify hashing unit that it is ready
        trap self in loop, similarly to msa

        eventually core is interrupted
        when interrupt_ack goes high, hardware can simply update a and e bufs

    interrupt can be the same for both and dummy routine
        interrupt:
            RETURNI enable

interrupt process
    only want to interrupt cores that are actually ready, otherwise wasting time
    can interrupt at most one core each clock cycle
        interrupt_acks will then come in each clock cycle as well

    need signals from unit to worker
        interrupt

    need signals from worker to unit
        interrupt request
        interrupt ack - can combine? probably!

    so each core needs 2 signals in
        msa_interrupt
        hash_interrupt

    and 2 signals out
        msa_interrupt_req
        hash_interrupt_req

    1. worker requests interrupt: raise corresponding signal in status_buf
    2. worker traps self in loop
    3. module services request by raising interrupt
    4. worker enters interrupt and raises interrupt_ack, at which point module lowers interrupt sig and connects circuitry

process from msa / hash module perspective
    sequential logic
        check which cores are requesting access
        interrupt one core each clock cycle

    combinatorial logic
        can exploit since only one interrupt_ack will be high at a time
        depending on which interrupt_ack is high, route inputs and outputs \
        through circuitry. all hashing/msa circuitry is combinatorial itself

msa extender module
    msa access sync
    msa circuitry

    hash extender module
        hash access sync
        hash circuitry

        core0
        core1
        core2
        core3
        core4
        core5
        core6
        core7

    hash extender module
        hash access sync
        hash circuitry

        core0
        core1
        core2
        core3
        core4
        core5
        core6
        core7
